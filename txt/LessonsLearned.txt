Hard Lessons Learned from Half a Lifetime Practicing Programming

I've spent half my life now practicing the art of software development. Like any other art, some development principles are generally applicable to any human endeavor. I'd like to share these with you.

Software development (also known as programming - there's no meaningful difference) consists primarily of two related but separate tasks. The first is translating definitions from one language to another; the second is managing complexity as those definitions grow.

When you think about translation, you probably think first of translation between natural languages: English to French, Japanese to Turkish and so forth. Programming has a remarkable similarity, except the translation goes from any natural language to an artificial language, which is essentially arithmetic.

At their core, computers aren't much more than glorified calculators. Programs whose output appears rich, organic and analog generate those results through massive amounts of calculation - basic arithmetic, but performed millions of times per second. Since every program's output consists of this arithmetic, another way to think about a program is as a giant mathematical equation. Facebook to Fortnite, Instagram to Indesign, from the calculator's point of view it's just an equation to be solved, with different variables provided at the time of execution.

In the bad old days, programmers had to deal directly with the raw arithmetic. Nowadays, we write using the same alphabetic and punctuation characters as natural language, and the calculator replaces each character with a numeric equivalent (why it's also called "coding"). Based on the result of the replacement, the numeric "word" instructs the calculator what arithmetic  to do next.

Between natural languages, concepts can get "lost in translation". Some phrase in one language doesn't have an exact match in the other, and the translator has to construct an equivalent. Programmers hone in like bomb-sniffing dogs on terms like "active" and "valid" and "soon", because they are loaded with implication and inference, which calculators cannot tolerate.

Software development has taught me that natural language is inherently imprecise. Someone says something and you nod, thinking you agree, only to find a couple sentences later that you and they are not talking about the same thing at all. Worse, I've learned if you question people for further clarity, you often find that they don't know exactly what they want.

Natural language intentionally trades away precision for speed and brevity. Someone says, "I saw a car", you can guess what they mean based on probability: four wheels, enclosed body, less than 40 or 50 years old. Programmers think a lot about what we call "edge cases": is a big pickup truck with dual back wheels still a "car"? what about those three wheel, two seat, open body vehicles? If that weird thing is a car, is a motorcycle a car? 

Very smart people have come up with terribly clever technical strategies to help manage this complexity, but ultimately it still falls on the developer to implement these techniques. On a large project, developers can't handle the collective weight of all that complexity. In the software, this results in bugs; for the developer personally, burnout.

In the late 90s, a group of developers invented a non-technical strategy called "Agile". Agile has gotten a bad rep from some folks over the years, but this stems from the same faulty logic that says "I've never seen a good toupee"- people blame poor experiences on the concept instead of their specific instance.

Agile acknowledges the difficulty of imprecision in software development, instead of pretending it doesn't exist. In a situation where definition is vague or incomplete, and massively complex, Agile provides a method to keep making  progress. People make Agile way more complicated than it needs to be, because it can be summed up very simply, and it goes like this.

Pick the most important thing to work on first, but break it down into the smallest possible pieces, until you have one thing that can be finished in a finite period of time. Work on that small piece, and only that small piece, until it's done. Then move on to the next small piece, and work on only that, while checking to make sure the current work hasn't affected the previous work. If it did, it means the two were somehow related, and you took on too much at once. But you should have enough information now to go back and change the first piece as needed. Treat that as your one and only task until you're again ready to move on. Now you have two independent and stable pieces finished, and you move to the third and repeat the process indefinitely.

Novice software developers make this mistake more often than any other: they try to do too much at once. They change several parts of the code at the same time, and when something breaks, they can't tell which part caused it.

Every January, many people make the same mistake in their personal lives. They resolve to get more exercise, eat right, quit drinking and write a novel. Then they get surprised and disappointed when none of those things work out.

Agile philosophy suggests you pick only one of those things, the one most important to you, and then break it down into the smallest achievable step. Don't get a gym membership and hit the free weights; don't even buy a FitBit. Instead, just go for a walk around the block at lunch. But do it every day, every week, every year. The smallest piece is always hard enough. Small changes you can consistently keep up are a million times better than lofty goals you can't. Maintain your gains.

Which brings us back to the practice of programming. Like music or yoga or any other practice, success requires the courage and patience to start working on one small thing at a time, and the humility to accept you can never achieve total perfection. It's not really about the arithmetic, or the coding languages; the thing we're all doing when we program is writing about desire. We express that desire in different ways, and that expression is what we practice. 

It's hard, but worth it. I wish you the best in your practice.
